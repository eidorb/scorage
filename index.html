<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Scorage</title>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
  <style type="text/css">
    .number-input {
      width: 4rem;
    }
    .vertical-middle {
      vertical-align: middle !important;
    }
    .text-center
      text-align: center;
    }
  </style>
</head>

<body>

  <div id="ractive-container" class="container"></div>

  <script id="template" type="text/ractive">

    <ul class="nav nav-tabs">
      <li role="presentation" class="{{ (view === 'score') ? 'active' : '' }}"><a href="#" on-click="set('view', 'score')">Score</a></li>
      <li role="presentation" class="{{ (view === 'setup') ? 'active' : '' }}"><a href="#" on-click="set('view', 'setup')">Setup</a></li>
    </ul>


    {{ #(view === 'score') }}
    <h1>Score sheet</h1>

    <table class="table">
      <thead>
        <th colspan="2">Round</th>
        {{ #each playerNames }}
        <th>{{ this }}</th>
        {{ /each }}
      </thead>
      <tbody>
        {{ #each rounds }}
        <tr>
          <th rowspan="3" class="vertical-middle">{{ round + 1 }}</th>
          <td>Bid</td>
          {{ #each bids: index }}
          <td><input type="number" value="{{ isNaN(this) ? '' : this }}" on-change="editBid: {{ round }}, {{ index }}" twoway="false" class="number-input"></td>
          {{ /each }}
          {{ #if(numRounds > 1) }}
          <td rowspan="3" class="vertical-middle text-center"><button type="button" class="btn btn-danger" on-click="removeRound: {{ round }}"><span class="glyphicon glyphicon-remove"></span>
</button></td>
          {{ /if }}
        </tr>
        <tr>
          <td>Tricks</td>
          {{ #each tricks: index }}
          <td><input type="number" value="{{ isNaN(this) ? '' : this }}" on-change="editTrick: {{ round }}, {{ index }}" twoway="false" class="number-input"></td>
          {{ /each }}
        </tr>
        <tr>
          <td>Score</td>
          {{ #each scores: index }}
          <td>{{ isNaN(this) ? '' : this }}</td>
          {{ /each }}
        </tr>
        {{ /each }}
      </tbody>
    </table>
    <div class="form-group">
      <button type="button" class="btn btn-success" on-click="addRound"><span class="glyphicon glyphicon-plus"></span></button>
    </div>
    {{ / }}


    {{ #(view === 'setup') }}
    <h1>Setup</h1>

    <h2>Player names</h2>

      {{ #each players: index }}
      <div class="form-group">
        <input placeholder="Player name" value="{{ name }}">
        {{ #if players.length > 1 }}
        <button type="button" class="btn btn-danger btn-xs" on-click="removePlayer: {{ index }}"><span class="glyphicon glyphicon-remove"></span></button>
        {{ /if }}
      </div>
      {{ /each}}
      <div class="form-group">
        <input placeholder="New player name" on-change="addPlayer">
      </div>


    <h2>Rules</h2>

    <div class="form-group">
      <select value="{{ rules }}">
        {{ #each ruleSets: id }}
        <option value="{{ id }}">{{ name }}</option>
        {{ /each }}
      </select>
    </div>

    <ul>
      {{ #each ruleSets[rules].details }}
      <li>{{ this }}</li>
      {{ /each }}
    </ul>
    {{ / }}

  </script>

  <script src="//cdnjs.cloudflare.com/ajax/libs/ractive/0.7.3/ractive.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/store.js/1.3.20/store.min.js"></script>

  <script>
    // Return a list of player objects. Player names are retrieved from storage
    // or a default player name is used.
    function retrievePlayers() {
      var names = store.get('names');
      if (!names) {
        console.log('No names in storage, using default player name.');
        names = ['Player 1'];
      }
      // Bids and tricks arrays are set to contain a single NaN.
      return names.map(function(name) {
        return {
          name: name,
          bids: [NaN],
          tricks: [NaN]
        };
      });
    }

    function retrieveRules() {
      var rules = store.get('rules');
      if (!rules) {
        console.log('No rules in storage, using default rules.');
        rules = 'shing';
      }
      return rules;
    }

    var ractive = new Ractive({
      el: '#ractive-container',

      template: '#template',

      data: {
        view: 'setup',

        players: retrievePlayers(),

        rules: retrieveRules(),

        ruleSets: {
          regular: {
            name: 'Regular',
            details: [
              '+1 point for each trick',
              '+10 points for taking the exact number of tricks bid (for non-zero bids)',
              '+5 points for taking zero tricks (for bids of zero)',
            ],
            score: function(bids, tricks) {
              // Return NaN if either bids or tricks is NaN.
              if (isNaN(bids) || isNaN(tricks)) {
                return NaN;
              }
              if (bids === tricks) {
                if (bids > 0) {
                  return tricks + 10;
                } else {
                  return tricks + 5;
                }
              } else {
                return tricks;
              }
            }
          },
          alternate: {
            name: 'Alternate',
            details: [
              '+1 point for each trick',
              '+10 points for taking the exact number of tricks bid (including bids of zero)',
              '-5 points for missing your bid',
            ],
            score: function(bids, tricks) {
              // Return NaN if either bids or tricks is NaN.
              if (isNaN(bids) || isNaN(tricks)) {
                return NaN;
              }
              if (bids === tricks) {
                return tricks + 10;
              } else {
                return tricks - 5;
              }
            }
          },
          shing: {
            name: "Shing's house rules",
            details: [
              '+1 point for each trick',
              '+10 points for taking the exact number of tricks bid (for non-zero bids)',
              '+5 points for taking zero tricks (for bids of zero)',
              '-5 points for missing your bid',
            ],
            score: function(bids, tricks) {
              // Return NaN if either bids or tricks is NaN.
              if (isNaN(bids) || isNaN(tricks)) {
                return NaN;
              }
              if (bids === tricks) {
                if (bids > 0) {
                  return tricks + 10;
                } else {
                  return tricks + 5;
                }
              } else {
                return tricks - 5;
              }
            }
          }
        }
      },

      computed: {
        playerNames: function() {
          return this.get('players').map(function(player) {
            return player.name;
          });
        },

        shortenedNames: function() {
          return uniquePrefixes(this.get('playerNames'));
        },

        // Number of rounds, calculated from the first player's bids.
        numRounds: function() {
          return this.get('players')[0].bids.length;
        },

        // Compute data for each round.
        rounds: function() {
          var players = this.get('players');
          var score = this.get('ruleSets')[this.get('rules')].score;
          // Create an array of objects containing data for each round.
          var rounds = [];
          for (var round = 0; round < this.get('numRounds'); round++) {
            // For each round, create arrays of bids, tricks and scores of each player.
            var bids = [];
            var tricks = [];
            var scores = [];
            for (var index = 0; index < players.length; index++) {
              bids.push(players[index].bids[round]);
              tricks.push(players[index].tricks[round]);
              scores.push(score(
                players[index].bids[round], players[index].tricks[round]));
            }
            rounds.push({
              round: round,
              bids: bids,
              tricks: tricks,
              scores: scores,
            });
          }
          return rounds;
        }
      }
    });

    ractive.on({
      addPlayer: function(event) {
        // The new player's bids and tricks arrays are filled with as many NaNs
        // as there are rounds.
        var bids = this.get('rounds').map(function() {
          return NaN;
        });
        // Copy of bids.
        var tricks = bids.slice();
        this.push('players', {
          name: event.node.value.trim(),
          bids: bids,
          tricks: tricks
        });
        // Clear the new player input.
        event.node.value = '';
      },

      removePlayer: function(event, index) {
        this.splice('players', index, 1);
      },

      editBid: function(event, round, index) {
        var parsed = parseInt(event.node.value.trim(), 10);
        this.set('players[' + index + '].bids[' + round + ']', parsed);
      },

      editTrick: function(event, round, index) {
        var parsed = parseInt(event.node.value.trim(), 10);
        this.set('players[' + index + '].tricks[' + round + ']', parsed);
      },

      addRound: function(event) {
        // Adding a round pushes a NaN on to all players' bids and tricks arrays.
        for (var index = 0; index < this.get('players').length; index++) {
          this.push('players[' + index + '].bids', NaN);
          this.push('players[' + index + '].tricks', NaN);
        }
      },

      removeRound: function(event, round) {
        for (var index = 0; index < this.get('players').length; index++) {
          this.splice('players[' + index + '].bids', round, 1);
          this.splice('players[' + index + '].tricks', round, 1);
        }
      },
    });

    // Observe player names and rules for changes. On changes, write to storage.
    ractive.observe({
      playerNames: function() {
        store.set('names', this.get('playerNames'));
      },

      rules: function() {
        store.set('rules', this.get('rules'));
      }
    }, {
      init: false
    });

    // Return the shortest unique prefixes from an array of strings.
    function uniquePrefixes(strings) {
      return strings.map(function(string, index, strings) {
        // Create incrementally longer prefixes of string.
        for (var prefixLength = 1; prefixLength <= string.length; prefixLength++) {
          // Uniqueness flag initially set true.
          var unique = true;
          // Create a prefix which increases in length each iteration.
          var prefix = string.substr(0, prefixLength);
          // Compare prefix to the same length prefix of each other string.
          for (var stringIndex = 0; stringIndex < strings.length; stringIndex++) {
            // Don't compare a prefixes of the same string.
            if (index === stringIndex) {
              continue;
            }
            var comparisonPrefix = strings[stringIndex].substr(0, prefixLength);
            // If a match is found, then the prefix is not unique. Do not
            // bother comparing the prefix with the remaining strings.
            if (prefix.toLowerCase() === comparisonPrefix.toLowerCase()) {
              unique = false;
              break;
            }
          }
          // Prefixes have been compared, return the prefix if unique.
          if (unique === true) {
            return prefix;
          }
        }
        // If no unique prefix was found, just return the string.
        return string;
      });
    }
  </script>
</body>
</html>
