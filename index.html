<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Scorage</title>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
</head>

<body>

  <div id="ractive-container" class="container"></div>

  <script id="template" type="text/ractive">

    <ul class="nav nav-tabs">
      <li role="presentation"><a href="#">Score</a></li>
      <li role="presentation" class="active"><a href="#">Setup</a></li>
    </ul>

    <h1>Score sheet</h1>

    <table>
      <thead>
        <th>Round</th>
        {{ #each shortenedNames }}
        <th colspan="3">{{ this }}</th>
        {{ /each }}
      </thead>
      <tbody>
        {{ #each rounds }}
        <tr>
          <td>{{ round + 1 }}</td>
          {{ #each data: index }}
          <td><input type="number" value="{{ isNaN(bid) ? '' : bid }}" on-change="editBid: {{ round }}, {{ index }}" twoway="false"/></td>
          <td><input type="number" value="{{ isNaN(trick) ? '' : trick }}" on-change="editTrick: {{ round }}, {{ index }}" twoway="false"/></td>
          <td>{{ isNaN(score) ? '' : score }}</td>
          {{ /each }}
          {{ #if(numRounds > 1) }}
          <td><button on-click="removeRound: {{ round }}">Remove</button></td>
          {{ /if }}
        </tr>
        {{ /each }}
      </tbody>
    </table>
    <button on-click="addRound">Add Round</button>

    <h1>Setup</h1>

    <h2>Player names</h2>

    <ul>
      {{ #each players: index }}
      <li>
        <input placeholder="Player name" value="{{ name }}"/>
        {{ #if players.length > 1 }}
        <button on-click="removePlayer: {{ index }}">Remove</button>
        {{ /if }}
      </li>
      {{ /each}}
      <li><input placeholder="New player name" on-change="addPlayer"></li>
    </ul>


    <h2>Rules</h2>

    <select value="{{ rules }}">
      {{ #each ruleSets: id }}
      <option value="{{ id }}">{{ name }}</option>
      {{ /each }}
    </select>

    <ul>
      {{ #each ruleSets[rules].details }}
      <li>{{ this }}</li>
      {{ /each }}
    </ul>

  </script>

  <script src="//cdnjs.cloudflare.com/ajax/libs/ractive/0.7.3/ractive.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/store.js/1.3.20/store.min.js"></script>

  <script>
    function retrievePlayers() {
      var names = store.get('names');
      if (!names) {
        console.log('No names in storage, using default player name.');
        names = ['Player 1'];
      }
      return names.map(function(name) {
        return {
          name: name,
          bids: [NaN],
          tricks: [NaN]
        };
      });
    }

    function retrieveRules() {
      var rules = store.get('rules');
      if (!rules) {
        console.log('No rules in storage, using default rules.');
        rules = 'shing';
      }
      return rules;
    }

    var ractive = new Ractive({
      el: '#ractive-container',

      template: '#template',

      data: {
        rounds: [0,1],

        players: retrievePlayers(),

        rules: retrieveRules(),

        ruleSets: {
          regular: {
            name: 'Regular',
            details: [
              '+1 point for each trick',
              '+10 points for taking the exact number of tricks bid (for non-zero bids)',
              '+5 points for taking zero tricks (for bids of zero)',
            ],
            score: function(bids, tricks) {
              if (bids === tricks) {
                if (bids > 0) {
                  return tricks + 10;
                } else {
                  return tricks + 5;
                }
              } else {
                return tricks;
              }
            }
          },
          alternate: {
            name: 'Alternate',
            details: [
              '+1 point for each trick',
              '+10 points for taking the exact number of tricks bid (including bids of zero)',
              '-5 points for missing your bid',
            ],
            score: function(bids, tricks) {
              if (bids === tricks) {
                return tricks + 10;
              } else {
                return tricks - 5;
              }
            }
          },
          shing: {
            name: "Shing's house rules",
            details: [
              '+1 point for each trick',
              '+10 points for taking the exact number of tricks bid (for non-zero bids)',
              '+5 points for taking zero tricks (for bids of zero)',
              '-5 points for missing your bid',
            ],
            score: function(bids, tricks) {
              if (bids === tricks) {
                if (bids > 0) {
                  return tricks + 10;
                } else {
                  return tricks + 5;
                }
              } else {
                return tricks - 5;
              }
            }
          }
        }
      },

      computed: {
        playerNames: function() {
          return this.get('players').map(function(player) {
            return player.name;
          });
        },

        shortenedNames: function() {
          return uniquePrefixes(this.get('playerNames'));
        },

        // Number of rounds, calculated from the first player's bids.
        numRounds: function() {
          return this.get('players')[0].bids.length;
        },

        // Compute data for each round.
        rounds: function() {
          var players = this.get('players');
          var score = this.get('ruleSets')[this.get('rules')].score;
          // Create an array of data for each round.
          var rounds = [];
          for (var round = 0; round < this.get('numRounds'); round++) {
            // Create an array of objects with bid, trick and score values for
            // each player.
            var data = [];
            for (var index = 0; index < players.length; index++) {
              var bid = players[index].bids[round];
              var trick = players[index].tricks[round];
              data.push({
                bid: bid,
                trick: trick,
                score: score(bid, trick)
              });
            }
            rounds.push({
              round: round,
              data: data
            });
          }
          return rounds;
        }
      }
    });

    ractive.on({
      addPlayer: function(event) {
        // The new player's bids and tricks arrays are filled with as many NaNs
        // as there are rounds.
        var bids = this.get('rounds').map(function() {
          return NaN;
        });
        // Copy of bids.
        var tricks = bids.slice();
        this.push('players', {
          name: event.node.value.trim(),
          bids: bids,
          tricks: tricks
        });
        // Clear the new player input.
        event.node.value = '';
      },

      removePlayer: function(event, index) {
        this.splice('players', index, 1);
      },

      editBid: function(event, round, index) {
        var parsed = parseInt(event.node.value.trim(), 10);
        this.set('players[' + index + '].bids[' + round + ']', parsed);
      },

      editTrick: function(event, round, index) {
        var parsed = parseInt(event.node.value.trim(), 10);
        this.set('players[' + index + '].tricks[' + round + ']', parsed);
      },

      addRound: function(event) {
        // Adding a round pushes a NaN on to all players' bids and tricks arrays.
        for (var index = 0; index < this.get('players').length; index++) {
          this.push('players[' + index + '].bids', NaN);
          this.push('players[' + index + '].tricks', NaN);
        }
      },

      removeRound: function(event, round) {
        for (var index = 0; index < this.get('players').length; index++) {
          this.splice('players[' + index + '].bids', round, 1);
          this.splice('players[' + index + '].tricks', round, 1);
        }
      },
    });

    // Observe player names and rules for changes. On changes, write to storage.
    ractive.observe({
      playerNames: function() {
        store.set('names', this.get('playerNames'));
      },

      rules: function() {
        store.set('rules', this.get('rules'));
      }
    }, {
      init: false
    });

    // Return the shortest unique prefixes from an array of strings.
    function uniquePrefixes(strings) {
      return strings.map(function(string, index, strings) {
        // Create incrementally longer prefixes of string.
        for (var prefixLength = 1; prefixLength <= string.length; prefixLength++) {
          // Uniqueness flag initially set true.
          var unique = true;
          // Create a prefix which increases in length each iteration.
          var prefix = string.substr(0, prefixLength);
          // Compare prefix to the same length prefix of each other string.
          for (var stringIndex = 0; stringIndex < strings.length; stringIndex++) {
            // Don't compare a prefixes of the same string.
            if (index === stringIndex) {
              continue;
            }
            var comparisonPrefix = strings[stringIndex].substr(0, prefixLength);
            // If a match is found, then the prefix is not unique. Do not
            // bother comparing the prefix with the remaining strings.
            if (prefix.toLowerCase() === comparisonPrefix.toLowerCase()) {
              unique = false;
              break;
            }
          }
          // Prefixes have been compared, return the prefix if unique.
          if (unique === true) {
            return prefix;
          }
        }
        // If no unique prefix was found, just return the string.
        return string;
      });
    }
  </script>
</body>
</html>
